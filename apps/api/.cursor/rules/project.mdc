---
description: Project guidlines
globs:
alwaysApply: false
---

# Hexagonal Booking App – LLM Project Specification

> Place this entire document in `.cursor/rules`. It instructs the AI assistant on how to scaffold and modify the project. The spec is **authoritative**; generated code **must** obey these rules.

---

## 0) Summary

We are building a **NestJS** example app that demonstrates **Hexagonal Architecture + DDD + CQRS + Repository pattern** for a simple **Booking** system where a user can book and pay for a reservation. Authentication is handled by an **external identity provider**. The goal is clarity and pedagogy over features.

**Tech**: Node 20+, NestJS 10+, TypeScript, class-validator/transformer, TypeORM or Prisma (adapter behind a Repository port), in-memory adapters for tests, Event Bus (Nest EventEmitter or custom), Stripe-like payment port (mock by default).

---

## 1) Bounded Contexts & Responsibilities

### 1.1 User Context (Supporting)

- **Aggregate Root**: `User` (id, name, emails\[], primaryEmail, roles\[])
- **Capabilities**: manage profile & primary email.
- **Notes**: No credential storage. Link to external Auth via `userId`.

### 1.2 Booking Context (Core)

- **Aggregate Root**: `Booking`
- **Props**: bookingId, userId, resourceId, timeSlot (VO), status: Pending|Confirmed|Cancelled
- **Behaviors**: create, cancel, markConfirmed (only after payment success)
- **Policies**: `ReservationPolicy` (domain service) checks future time, no overlap, resource availability.
- **Domain Events**: `BookingCreated`, `BookingCancelled`, `BookingConfirmed`.

### 1.3 Payment Context (Supporting)

- **Aggregate Root**: `Payment`
- **Props**: paymentId, bookingId, amount (Money VO), status: Initiated|Succeeded|Failed
- **Behaviors**: initiate, succeed, fail
- **Domain Events**: `PaymentSucceeded`, `PaymentFailed`.
- **Ports**: `PaymentProviderPort` (charge, refund, getStatus). Default mock adapter.

### 1.4 Notification Context (Optional, Integration)

- **Services**: react to domain events to send notifications (email/SMS). No heavy aggregates.

### 1.5 Auth (External System)

- **Not a local bounded context**. We only trust `userId` + claims from the external provider. Provide `AuthGuard` adapter that validates tokens and injects `userId`.

---

## 2) Architecture Rules (Hexagonal)

1. **Domain is framework-agnostic**: no Nest imports in `domain/*`.
2. **Ports in domain**, **Adapters in infrastructure**.
3. **Application layer owns use-cases** (CQRS handlers, transactions, orchestration).
4. **Domain events** raised from aggregates; **Application** publishes them to the bus.
5. **Repositories are ports**. Infrastructure implements them (TypeORM/Prisma/InMemory).
6. **CQRS**: Mutations via **Commands**; Reads via **Queries** with dedicated handlers.
7. **Validation**: VO constructors enforce invariants; handlers do request DTO validation.
8. **Transactions**: command handlers wrap changes atomically where needed.
9. **Idempotency**: commands that can be retried must be idempotent.
10. **No anemic domain**: put behaviors on aggregates/services, not only data.

---

## 3) Project Structure (NestJS + DDD + CQRS)

```
src/
  modules/
    user/
      application/
        commands/
          create-user.command.ts
          handlers/create-user.handler.ts
        queries/
          get-user.query.ts
          handlers/get-user.handler.ts
      domain/
        aggregates/user.aggregate.ts
        value-objects/email.vo.ts
        repositories/user.repository.ts           # Port
        events/user-created.event.ts
      infrastructure/
        persistence/
          orm/user.orm-entity.ts                  # or prisma schema in prisma/
          user.repository.impl.ts                 # Adapter
        controllers/user.controller.ts

    booking/
      application/
        commands/
          create-booking.command.ts
          cancel-booking.command.ts
          confirm-booking.command.ts
          handlers/
            create-booking.handler.ts
            cancel-booking.handler.ts
            confirm-booking.handler.ts
        queries/
          get-booking.query.ts
          list-bookings.query.ts
          handlers/
            get-booking.handler.ts
            list-bookings.handler.ts
      domain/
        aggregates/booking.aggregate.ts
        value-objects/timeslot.vo.ts
        services/reservation-policy.service.ts
        repositories/booking.repository.ts        # Port
        events/
          booking-created.event.ts
          booking-confirmed.event.ts
          booking-cancelled.event.ts
      infrastructure/
        persistence/
          orm/booking.orm-entity.ts
          booking.repository.impl.ts
        controllers/booking.controller.ts
        subscribers/booking.event-subscribers.ts

    payment/
      application/
        commands/
          initiate-payment.command.ts
          complete-payment.command.ts
        queries/
          get-payment-status.query.ts
          handlers/
            initiate-payment.handler.ts
            complete-payment.handler.ts
            get-payment-status.handler.ts
      domain/
        aggregates/payment.aggregate.ts
        value-objects/money.vo.ts
        repositories/payment.repository.ts        # Port
        events/
          payment-succeeded.event.ts
          payment-failed.event.ts
        ports/payment-provider.port.ts            # External Port
      infrastructure/
        adapters/payment-provider.mock.ts         # Default
        adapters/payment-provider.stripe.ts       # Example
        persistence/
          orm/payment.orm-entity.ts
          payment.repository.impl.ts
        controllers/payment.controller.ts

    notification/
      application/event-handlers/
        on-booking-confirmed.handler.ts
        on-booking-cancelled.handler.ts
      domain/services/notification.service.ts
      infrastructure/adapters/
        email.adapter.ts
        sms.adapter.ts

  shared/
    application/bus/
      command-bus.ts
      query-bus.ts
      event-bus.ts
    domain/
      base-entity.ts
      domain-event.ts
      uuid.vo.ts
    infrastructure/
      auth/auth.guard.ts
      config/config.module.ts
      event-bus/nest-event-bus.adapter.ts

main.ts
app.module.ts
```

---

## 4) CQRS Contracts (Examples)

### 4.1 Commands

```ts
// booking/application/commands/create-booking.command.ts
export class CreateBookingCommand {
  constructor(
    public readonly userId: string,
    public readonly resourceId: string,
    public readonly start: string, // ISO
    public readonly end: string, // ISO
  ) {}
}
```

```ts
// payment/application/commands/initiate-payment.command.ts
export class InitiatePaymentCommand {
  constructor(
    public readonly bookingId: string,
    public readonly amountCents: number,
    public readonly currency: 'USD' | 'MXN' | 'EUR',
  ) {}
}
```

### 4.2 Queries

```ts
export class GetBookingQuery {
  constructor(public readonly bookingId: string) {}
}
export class ListBookingsQuery {
  constructor(public readonly userId: string) {}
}
```

### 4.3 Domain Events (shape)

```ts
export interface DomainEvent<T = unknown> {
  readonly name: string; // e.g., 'booking.created'
  readonly occurredOn: Date;
  readonly payload: T;
}
```

- `BookingCreated { bookingId, userId, resourceId, start, end }`
- `BookingConfirmed { bookingId }`
- `PaymentSucceeded { paymentId, bookingId, amount, currency }`

**Rule**: Events are immutable and published by the Application layer immediately after aggregate state changes persist.

---

## 5) Aggregates & Value Objects (Guidance)

- **Aggregate roots** expose intent methods, e.g., `Booking.create()`, `booking.cancel()`, `booking.applyPaymentSuccess()`.
- **Value Objects** validate invariants in constructor: `TimeSlot` ensures start < end, in future, duration ≤ policy limit.
- **Do not leak primitives** when a VO exists (use `Money`, `TimeSlot`).
- **Avoid setters**; prefer methods that express ubiquitous language.

**Example `TimeSlot`**

```ts
export class TimeSlot {
  private constructor(
    readonly start: Date,
    readonly end: Date,
  ) {}
  static create(start: Date, end: Date) {
    if (!(start instanceof Date) || !(end instanceof Date))
      throw new Error('Invalid dates');
    if (start >= end) throw new Error('start must be before end');
    return new TimeSlot(start, end);
  }
  overlaps(other: TimeSlot): boolean {
    return this.start < other.end && other.start < this.end;
  }
}
```

---

## 6) Ports & Repositories

- **Define repository interfaces in `domain/repositories`** with Ubiquitous Language methods:
  - `BookingRepository.save(booking: Booking): Promise<void>`
  - `BookingRepository.findById(id: BookingId): Promise<Booking | null>`
  - `BookingRepository.findOverlapping(resourceId: ResourceId, slot: TimeSlot): Promise<Booking[]>`

- **Infra implements** these using chosen persistence (TypeORM/Prisma). Provide an **InMemory** implementation for tests.
- **PaymentProviderPort** defines `charge(amount: Money, reference: string): Promise<ChargeResult>`.

---

## 7) Application Layer Rules

- **Handlers** do:
  1. Validate input DTOs.
  2. Load aggregates via repositories.
  3. Call domain behaviors.
  4. Persist via repositories.
  5. Publish domain events.

- **Never** embed business logic in handlers.
- **Transactions**: wrap steps 2–4 atomically when changing multiple aggregates.

---

## 8) HTTP API (Pedagogical Routes)

- `POST /bookings` → `CreateBookingCommand`
- `POST /bookings/{id}/cancel` → `CancelBookingCommand`
- `POST /payments` → `InitiatePaymentCommand`
- `GET /bookings/{id}` → `GetBookingQuery`
- `GET /users/{id}` → user profile (read model)

**DTO Constraints**: use `class-validator`. Accept/return ISO dates, snake-free JSON.

---

## 9) Security & Auth Integration

- Use an `AuthGuard` adapter that extracts `userId` from the external provider (mock for local/dev).
- Expose `@CurrentUserId()` decorator to inject `userId` into controllers/handlers.
- **Do not** model passwords/roles in `user/` context. If roles are needed, read from token claims.

---

## 10) Read Models & Projections

- Queries may read from a **separate projection** optimized for reads (same DB for demo is fine).
- Keep projection mappers in `infrastructure/persistence/*/mappers` or a `read-models/` folder.

---

## 11) Testing Strategy

- **Unit**: aggregates & VOs with in-memory repositories.
- **Application**: command/query handlers with mocks for repos/ports.
- **Integration**: repository implementations against a real DB container (or sqlite in memory) and event bus wiring.
- Provide `fixtures/` and `mother` builders for common objects.

---

## 12) Code Style & Conventions

- **Naming**: `*.aggregate.ts`, `*.vo.ts`, `*.repository.ts`, `*.port.ts`, `*.event.ts`, `*.command.ts`, `*.query.ts`.
- **Enums**: TypeScript `enum` or string unions; persist as strings.
- **Dates**: always ISO strings at API boundary; convert to `Date` in domain.
- **Error Handling**: domain-specific errors (e.g., `OverlappingBookingError`). Map to HTTP codes at controller level.
- **Logging**: structured logs in handlers and adapters; no logs in domain.

---

## 13) Scaffolding Tasks (what the LLM should generate on request)

- New **bounded context module** with application/domain/infrastructure skeletons.
- New **aggregate** with VO(s), repository port, factory, and tests.
- New **command** + handler with validation DTO and e2e route.
- New **query** + handler and controller route.
- **Repository adapter** for TypeORM or Prisma, plus in-memory variant.
- **Event bus** adapter (Nest EventEmitter) and example subscribers.
- **Auth guard** + `@CurrentUserId()` decorator stub.

Each scaffold must include: unit tests, example usage, and wire-up in `app.module.ts`.

---

## 14) Acceptance Criteria (Definition of Done)

- Domain logic only in domain layer (no Nest imports there).
- Commands/Queries have handlers and are registered.
- Repository interfaces have at least one implementation (InMemory) and tests.
- Domain events are emitted and an example subscriber reacts.
- HTTP controllers exist for demo endpoints with `AuthGuard` applied where appropriate.
- Validation errors return 400 with helpful messages; domain errors mapped appropriately.
- README snippet for how to run and invoke sample flows.

---

## 15) Example Flow (Happy Path)

1. `POST /bookings` with `userId` from token and a valid `TimeSlot` → `BookingCreated` raised.
2. `POST /payments` with `bookingId` → Payment initiated; mock provider succeeds → `PaymentSucceeded` raised.
3. Booking app subscribes to `PaymentSucceeded` → loads booking and calls `confirm()` → persists and emits `BookingConfirmed`.
4. Notification subscribers send email (mock) on `BookingConfirmed`.

---

## 16) Environment & Config (example)

- `PORT=3000`
- `DATABASE_URL=postgres://...` (or sqlite for demo)
- `PAYMENT_PROVIDER=mock|stripe`
- `AUTH_ISSUER=...` `AUTH_AUDIENCE=...`

Use a `ConfigModule` to read env and inject typed config.

---

## 17) Non-Functional Requirements

- Deterministic unit tests; no network in unit scope.
- Clear separation of concerns; no leaking infra details into domain.
- Small, readable files; prefer composition over inheritance.

---

## 18) What NOT to Generate

- No password storage or custom JWT issuance logic.
- No direct ORM entities inside domain.
- No business logic in controllers/adapters.

---

## 19) Quick Prompts (for developers)

- **"Generate a Booking aggregate with create/cancel/confirm and a TimeSlot VO, plus unit tests."**
- **"Add CreateBookingCommand handler that checks ReservationPolicy via repository to prevent overlaps; include in-memory repo and tests."**
- **"Create PaymentProviderPort with mock adapter that always succeeds for now; wire InitiatePaymentCommand."**
- **"Add event subscriber so PaymentSucceeded confirms the Booking and emits BookingConfirmed."**

---

## 20) README Snippet (autogenerate when asked)

- How to run (`pnpm i && pnpm start:dev`), migrate DB (if using TypeORM/Prisma), and curl examples for the happy path.

---

**End of Spec**
